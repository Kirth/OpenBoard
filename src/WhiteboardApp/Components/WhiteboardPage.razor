@page "/board/{BoardId}"
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.JSInterop
@using WhiteboardApp.Services
@using WhiteboardApp.Models
@using WhiteboardApp.Components.Board
@using System.Text.Json
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@inject BoardService BoardService
@inject ElementService ElementService
@inject IUserService UserService
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject AuthenticationStateProvider AuthenticationStateProvider
@implements IAsyncDisposable

<PageTitle>@boardName - OpenBoard</PageTitle>

<link href="css/board-components.css" rel="stylesheet" />

<style>
.loading-page {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: var(--bg-primary, #ffffff);
}

.loading-container {
    text-align: center;
    color: var(--text-primary, #333);
}

.loading-spinner {
    border: 3px solid var(--border-color, #f3f3f3);
    border-top: 3px solid var(--accent-primary, #007bff);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin: 0 auto 16px;
}

@@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
</style>

@if (isLoadingAccess)
{
    <div class="loading-page">
        <div class="loading-container">
            <div class="loading-spinner"></div>
            <p>Loading board...</p>
        </div>
    </div>
}
else if (hasAccessError)
{
    <div class="access-denied-page">
        <header class="access-denied-header">
            <div class="access-denied-header-content">
                <h1 class="brand-logo">
                    <i class="fas fa-draw-polygon icon-lg"></i>
                    OpenBoard
                </h1>
                <nav class="header-nav">
                    <button class="nav-link" @onclick="NavigateToHome">
                        <i class="fas fa-home icon-sm"></i>
                        Home
                    </button>
                </nav>
            </div>
        </header>
        
        <main class="access-denied-main">
            <div class="access-denied-container">
                <div class="access-denied-content">
                    <div class="access-denied-icon">
                        <i class="fas fa-user-shield"></i>
                    </div>
                    <h2>Access Required</h2>
                    <p>
                        @if (accessErrorMessage.Contains("private"))
                        {
                            <span>This board is private and requires authentication.<br/>Please sign in to continue.</span>
                        }
                        else if (accessErrorMessage.Contains("permission"))
                        {
                            <span>You don't have permission to access this board.<br/>Contact the board owner for access.</span>
                        }
                        else if (accessErrorMessage.Contains("Invalid"))
                        {
                            <span>The board ID appears to be invalid.<br/>Please check the URL and try again.</span>
                        }
                        else
                        {
                            <span>We encountered an issue loading this board.<br/>Please try again or contact support if the problem persists.</span>
                        }
                    </p>
                    <div class="access-denied-actions">
                        <button class="btn btn-primary" @onclick="NavigateToLogin">
                            <i class="fas fa-sign-in-alt icon-md"></i>
                            Sign In
                        </button>
                        <button class="btn btn-secondary" @onclick="NavigateToHome">
                            <i class="fas fa-home icon-md"></i>
                            Go Home
                        </button>
                    </div>
                </div>
            </div>
        </main>
    </div>
}
else
{
    <div class="board-container">
        <!-- Status Bar Component -->
        <BoardStatusBar 
            BoardName="@boardName"
            BoardId="@BoardId"
            IsConnected="@signalRConnected"
            OnClearBoard="ClearBoard"
            OnDuplicateBoard="DuplicateBoard"
            OnBoardSettingsChanged="RefreshBoardInfo" />
        
        <!-- Canvas Component -->
        <BoardCanvas 
            BoardId="@BoardId"
            CurrentUserName="@currentUserName"
            OnCanvasReady="OnCanvasReady" />
        
        <!-- Toolbar Component -->
        <BoardToolbar 
            CurrentTool="@currentTool"
            SelectedShapeType="@selectedShapeType"
            OnToolSelected="SetTool"
            OnShapeTypeSelected="OnShapeTypeSelected" />
        
        <!-- Context Menu Component -->
        <BoardContextMenu />
        
        <!-- Minimap -->
        <div class="minimap-container">
            <canvas id="minimap-canvas" width="200" height="150"></canvas>
            <div id="minimap-viewport" class="minimap-viewport"></div>
        </div>
        
        <input type="file" id="image-upload" accept="image/*" class="hidden" />
    </div>
}

@code {
    [Parameter] public string BoardId { get; set; } = "";
    
    private ElementReference canvasElement;
    private string currentTool = "select";
    private string boardName = "Loading...";
    private bool signalRConnected = false;
    private string currentUserName = "Anonymous";
    private bool isLoadingAccess = true; // Start in loading state
    private bool hasAccessError = false;
    private string accessErrorMessage = "";
    
    // Shape tool state
    private string selectedShapeType = "rectangle";

    protected override async Task OnInitializedAsync()
    {
        // Don't do any access checking during prerender - just set loading state
        isLoadingAccess = true;
        hasAccessError = false;
        boardName = "Loading...";
    }

    protected override async Task OnParametersSetAsync()
    {
        // Ensure we're in loading state when parameters change
        isLoadingAccess = true;
        hasAccessError = false;
        boardName = "Loading...";
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadCurrentUser(); // Load user after authentication is established
            await LoadBoardInfo(); // Reload board info now that we have user context
            
            // Only initialize canvas and SignalR if we have access to the board
            if (!hasAccessError)
            {
                // Wait a bit to ensure DOM is fully rendered
                await Task.Delay(100);
                await InitializeCanvas();
                await InitializeSignalR();
            }
        }
    }

    private async Task LoadBoardInfo()
    {
        try
        {
            isLoadingAccess = true; // Set loading while checking access
            hasAccessError = false;
            accessErrorMessage = "";
            
            if (Guid.TryParse(BoardId, out var boardGuid))
            {
                // Get current user and check board access
                var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
                User? currentUser = null;
                
                if (authState.User.Identity?.IsAuthenticated == true)
                {
                    try
                    {
                        currentUser = await UserService.GetOrCreateUserAsync(authState.User);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"WhiteboardPage: Failed to load user: {ex.Message}");
                        // Fall back to anonymous access if user service fails
                        currentUser = null;
                    }
                }
                
                Models.Board? board = null;
                
                if (currentUser != null)
                {
                    // Authenticated user - use access check
                    board = await BoardService.GetBoardWithAccessCheckAsync(boardGuid, currentUser, BoardRole.Viewer);
                }
                else
                {
                    // Anonymous user - check if board allows anonymous access
                    var boardInfo = await BoardService.GetBoardAsync(boardGuid);
                    if (boardInfo != null && (boardInfo.AccessLevel == BoardAccessLevel.Public || boardInfo.AccessLevel == BoardAccessLevel.Unlisted))
                    {
                        board = boardInfo;
                    }
                    else if (boardInfo != null && boardInfo.AccessLevel == BoardAccessLevel.Private)
                    {
                        hasAccessError = true;
                        accessErrorMessage = "This board is private. Please sign in to access it.";
                        boardName = "Access Denied";
                        StateHasChanged();
                        return;
                    }
                }
                
                if (board != null)
                {
                    boardName = board.Name;
                }
                else
                {
                    hasAccessError = true;
                    accessErrorMessage = "You don't have permission to access this board.";
                    boardName = "Access Denied";
                }
                
                // Trigger a re-render to update the page title
                StateHasChanged();
            }
            else
            {
                hasAccessError = true;
                accessErrorMessage = "Invalid board ID format.";
                boardName = "Invalid Board ID";
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading board info: {ex.Message}");
            hasAccessError = true;
            accessErrorMessage = "An error occurred while loading the board.";
            boardName = "Error Loading Board";
            StateHasChanged();
        }
        finally
        {
            isLoadingAccess = false; // Always stop loading regardless of success/failure
            StateHasChanged();
        }
    }

    private async Task LoadCurrentUser()
    {
        try
        {
            // Try multiple times to get authentication state (Blazor Server timing issue)
            AuthenticationState authState = null;
            for (int i = 0; i < 3; i++)
            {
                authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
                if (authState.User.Identity?.IsAuthenticated == true && authState.User.Claims.Any())
                {
                    break;
                }
                await Task.Delay(100); // Wait a bit for claims to populate
            }
            
            Console.WriteLine($"Auth State - IsAuthenticated: {authState?.User.Identity?.IsAuthenticated}");
            Console.WriteLine($"Auth State - Identity Type: {authState?.User.Identity?.GetType()}");
            Console.WriteLine($"Auth State - Authentication Type: {authState?.User.Identity?.AuthenticationType}");
            Console.WriteLine($"Auth State - Name: '{authState?.User.Identity?.Name}'");
            Console.WriteLine($"Claims count: {authState?.User.Claims.Count()}");
            
            // Force authenticated for testing if we have any claims or a name
            bool isLoggedIn = authState?.User.Identity?.IsAuthenticated == true || 
                             !string.IsNullOrEmpty(authState?.User.Identity?.Name) ||
                             authState?.User.Claims.Any() == true;
            
            Console.WriteLine($"Computed isLoggedIn: {isLoggedIn}");
            
            if (isLoggedIn)
            {
                Console.WriteLine("User is authenticated, checking claims...");
                
                // Log all available claims for debugging
                foreach (var claim in authState.User.Claims)
                {
                    Console.WriteLine($"Claim - Type: '{claim.Type}', Value: '{claim.Value}'");
                }
                
                // Try to get display name or email, fallback to name claim
                var extractedName = authState.User.FindFirst("name")?.Value 
                                ?? authState.User.FindFirst(ClaimTypes.Name)?.Value
                                ?? authState.User.FindFirst("preferred_username")?.Value
                                ?? authState.User.FindFirst("email")?.Value
                                ?? authState.User.FindFirst("sub")?.Value;
                
                // Try to use extracted name first, then fallback
                currentUserName = extractedName ?? "john.doe"; // Use extracted name if available
                
                Console.WriteLine($"Extracted from claims: '{extractedName}'");
                Console.WriteLine($"Final username: '{currentUserName}'");
            }
            else
            {
                currentUserName = "Anonymous";
                Console.WriteLine("User is not authenticated, using Anonymous");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading current user: {ex.Message}");
            currentUserName = "Anonymous";
        }
    }


    private async Task InitializeCanvas()
    {
        int maxRetries = 3;
        int delay = 200;
        
        for (int i = 0; i < maxRetries; i++)
        {
            try
            {
                Console.WriteLine($"Attempting canvas initialization (attempt {i + 1}/{maxRetries})");
                
                // Initialize the new modular system
                await JSRuntime.InvokeVoidAsync("initializeApplication");
                
                // Set up reference for JavaScript to call back to Blazor
                var dotNetRef = DotNetObjectReference.Create(this);
                await JSRuntime.InvokeVoidAsync("setBlazorReference", dotNetRef);
                
                Console.WriteLine("Canvas initialization successful");
                return; // Success, exit the retry loop
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Canvas initialization attempt {i + 1} failed: {ex.Message}");
                
                if (i < maxRetries - 1) // Don't delay on the last attempt
                {
                    await Task.Delay(delay);
                    delay *= 2; // Exponential backoff
                }
            }
        }
        
        Console.WriteLine("Canvas initialization failed after all retry attempts");
    }

    private async Task InitializeSignalR()
    {
        try
        {
            // Initialize SignalR using the modular JavaScript client
            var success = await JSRuntime.InvokeAsync<bool>("initializeSignalR", BoardId);
            signalRConnected = success;
            
            // Update UI to reflect connection status
            StateHasChanged();
            
            // Note: Only using JavaScript SignalR client to avoid duplicate connections
            // The JavaScript client handles all SignalR communication including cursor tracking
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SignalR initialization failed: {ex.Message}");
            signalRConnected = false;
            StateHasChanged();
        }
    }

    private async Task OnCanvasReady(ElementReference canvas)
    {
        canvasElement = canvas;
    }

    private async Task SetTool(string tool)
    {
        currentTool = tool;
        await JSRuntime.InvokeVoidAsync("setCurrentTool", tool);
        StateHasChanged();
    }

    private async Task OnShapeTypeSelected(string shapeType)
    {
        selectedShapeType = shapeType;
        await SetTool(shapeType);
    }


    private async Task ClearBoard()
    {
        try
        {
            // Clear all elements from the database
            if (Guid.TryParse(BoardId, out var boardGuid))
            {
                var elements = await BoardService.GetBoardElementsAsync(boardGuid);
                foreach (var element in elements)
                {
                    await ElementService.DeleteElementAsync(element.Id);
                }
            }
            
            // Clear canvas and notify via JavaScript
            await JSRuntime.InvokeVoidAsync("clearCanvasFromBlazor");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to clear board: {ex.Message}");
        }
    }

    private async Task DuplicateBoard(string newBoardName)
    {
        try
        {
            if (Guid.TryParse(BoardId, out var sourceBoardGuid))
            {
                var newBoard = await BoardService.DuplicateBoardAsync(sourceBoardGuid, newBoardName);
                await JSRuntime.InvokeVoidAsync("showNotification", $"Board duplicated successfully as '{newBoardName}'", "success");
                
                // Navigate to the new board
                Navigation.NavigateTo($"/board/{newBoard.Id}");
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("showNotification", "Invalid board ID", "error");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to duplicate board: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("showNotification", "Failed to duplicate board", "error");
        }
    }


    // Methods callable from JavaScript
    [JSInvokable]
    public void UpdateCurrentTool(string tool)
    {
        currentTool = tool;
        StateHasChanged();
    }

    [JSInvokable]
    public void UpdateZoomLevel(int zoomPercentage)
    {
        // Update zoom display if needed
        StateHasChanged();
    }

    [JSInvokable]
    public async Task<string> SaveStickyNote(string elementId, string content, double x, double y, double width, double height)
    {
        try
        {
            var element = new BoardElement
            {
                BoardId = Guid.Parse(BoardId),
                Type = ElementType.StickyNote,
                X = x,
                Y = y,
                Width = width,
                Height = height,
                Data = JsonDocument.Parse(JsonSerializer.Serialize(new { content = content })),
                CreatedBy = currentUserName
            };

            var savedElement = await ElementService.AddElementAsync(element);
            return savedElement.Id.ToString();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to save sticky note: {ex.Message}");
            return "";
        }
    }

    [JSInvokable]
    public async Task<string> SaveTextElement(string elementId, string content, double x, double y, double width, double height, string fontSize, string fontFamily, string textColor)
    {
        try
        {
            var element = new BoardElement
            {
                BoardId = Guid.Parse(BoardId),
                Type = ElementType.Text,
                X = x,
                Y = y,
                Width = width,
                Height = height,
                Data = JsonDocument.Parse(JsonSerializer.Serialize(new 
                { 
                    content = content,
                    fontSize = fontSize,
                    fontFamily = fontFamily,
                    textColor = textColor
                })),
                CreatedBy = currentUserName
            };

            var savedElement = await ElementService.AddElementAsync(element);
            return savedElement.Id.ToString();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to save text element: {ex.Message}");
            return "";
        }
    }

    [JSInvokable]
    public async Task UpdateStickyNote(string elementId, string content)
    {
        try
        {
            if (Guid.TryParse(elementId, out var elementGuid))
            {
                var element = await ElementService.GetElementAsync(elementGuid);
                if (element != null)
                {
                    element.Data = JsonDocument.Parse(JsonSerializer.Serialize(new { content = content }));
                    await ElementService.UpdateElementAsync(element);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to update sticky note: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task UpdateTextElement(string elementId, string content, string fontSize, string fontFamily, string textColor)
    {
        try
        {
            if (Guid.TryParse(elementId, out var elementGuid))
            {
                var element = await ElementService.GetElementAsync(elementGuid);
                if (element != null)
                {
                    element.Data = JsonDocument.Parse(JsonSerializer.Serialize(new 
                    { 
                        content = content,
                        fontSize = fontSize,
                        fontFamily = fontFamily,
                        textColor = textColor
                    }));
                    await ElementService.UpdateElementAsync(element);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to update text element: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task<string> LoadBoardElements()
    {
        try
        {
            if (Guid.TryParse(BoardId, out var boardGuid))
            {
                var elements = await BoardService.GetBoardElementsAsync(boardGuid);
                return JsonSerializer.Serialize(elements.Select(e => {
                    // For shapes, return the original shape type instead of "Shape"
                    string elementType = e.Type.ToString();
                    if (e.Type == ElementType.Shape && e.Data != null)
                    {
                        try
                        {
                            var dataDict = JsonSerializer.Deserialize<Dictionary<string, object>>(e.Data.RootElement.GetRawText());
                            if (dataDict?.ContainsKey("shapeType") == true)
                            {
                                elementType = dataDict["shapeType"]?.ToString() ?? elementType;
                            }
                        }
                        catch
                        {
                            // Fallback to enum string if parsing fails
                        }
                    }
                    
                    return new
                    {
                        id = e.Id.ToString(),
                        type = elementType,
                        x = e.X,
                        y = e.Y,
                        width = e.Width,
                        height = e.Height,
                        zIndex = e.ZIndex,
                        data = e.Data?.RootElement,
                        createdBy = e.CreatedBy
                    };
                }));
            }
            return "[]";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load board elements: {ex.Message}");
            return "[]";
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            // Basic cleanup when component is disposed
            if (!string.IsNullOrEmpty(BoardId))
            {
                Console.WriteLine($"Disposing WhiteboardPage for board {BoardId}");
                await JSRuntime.InvokeVoidAsync("disconnectFromBoard");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during WhiteboardPage disposal: {ex.Message}");
        }
    }

    private void NavigateToLogin()
    {
        Navigation.NavigateTo("/Account/Login", forceLoad: true);
    }

    private void NavigateToHome()
    {
        Navigation.NavigateTo("/");
    }

    private async Task RefreshBoardInfo()
    {
        // Refresh board information after settings are changed
        try 
        {
            if (Guid.TryParse(BoardId, out var boardGuid))
            {
                var board = await BoardService.GetBoardAsync(boardGuid);
                if (board != null)
                {
                    boardName = board.Name;
                    StateHasChanged(); // Trigger re-render to update page title
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error refreshing board info: {ex.Message}");
        }
    }
}